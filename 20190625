1--扩展外设方法1：
    在ubuntu下通过compile.sh编译指令找不到编译写的VM.h文件，通过g++编译器编译生成.o文件链接到Bootloader下的engine.ino.4.elf文件，如果单独编译模块，
    这时会有很多的全局变量是不可知的，链接时就是读取已经编译链接好的固件elf文件，获得符号表，然后对模块进行链接操作。运行时，模块里的函数地址作为CCall
    指令的参数，VM直接跳转到具体函数地址执行AVR机器码。
    
    这种方式主要为了解决硬件种类过多，驱动无法全部静态编译到固件的问题
    
    但是这种方式缺点也比较多，比如生成的字节码过大，容易导致上传失败；版本的兼容要求比较高，必须使用同一版本的固件灯。现在由于基本驱动代码做了精简，基本
    都已经编译到固件里了，这种方式就不再使用了。
    
    c，c++程序从源代码编译成一个可执行文件，需要预编译：处理所有带#的命令，删注释等，编译：词法分析，语法分析，语义分析，目标代码生成，目标代码优化，
    汇编：将汇编代码变成机器码，链接：把各个模块之间相互引用的部分处理好使得各个模块之间能够正确衔接。
    
    
    单独编译一个模块，它引用的外部符号（函数，全局变量）等的地址是未知的，编译器或者汇编器会在引用未知符号的地方，根据指令类型不同，生成不同的relocation
    信息，需要再链接阶段将这些缺失的信息回填成正确的指令。由于我们的魔魁啊要附着在已经编译好的固件程序上执行的，所以实际上这些缺失的全局符号的地址信息
    已经包含在固件的elf文件的符号表中了，链接程序的工作实际就是从这个符号表中找到自己引用过的全局符号，比如printf，malloc之类的地址，然后回填到
    二进制指令的对应的地址段中。
    
    CCAll模块不是单纯的字节码，而是字节码和avr机器指令的混合，实际的驱动逻辑都是avr机器码，所以需要引用固件里面的符号。调用CCAll的逻辑是字节码。
    实际上机器码要比字节码更底层，所以同样的功能，用机器码产生的指令数据更大，而用字节码会小的多，便于蓝牙传输；另外，由高级语言到字节码的编译
    更简单容易实现。
